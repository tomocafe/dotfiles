#!/usr/bin/env python3

import os
import stat
import sys
import argparse
import glob
from collections import defaultdict

def get_inodes(d):
    inodes = defaultdict(int)
    # Single file
    if os.path.isfile(d):
        inode = os.lstat(d)[stat.ST_INO]
        inodes[inode] += 1
        return inodes
    # Directory: get all inodes of files recursively
    for root, dirs, files in os.walk(d):
        for f in files:
            inode = os.lstat(os.path.join(root, f))[stat.ST_INO]
            inodes[inode] += 1
    return inodes

def find(f, args):
    matches = []
    inodes = get_inodes(f)
    for backupdirname in args.I:
        backupdirs = [backupdirname] + ['*'] * (args.depth - 1)
        dirs = os.path.abspath(f).split(os.path.sep)
        for i in range(1, len(dirs)):
            newdirs = dirs[:]
            newdirs[i:i] = backupdirs
            for match in glob.glob(os.path.join(os.path.sep, *newdirs)):
                backupinodes = get_inodes(match)
                if inodes == backupinodes or args.all:
                    matches.append(match)
    return matches

def prompt(f):
    q = 'Remove {}? (Yy) > '.format(f)
    # If getch is available (pip install getch), use it;
    # otherwise fall back to input() which requires pressing return after each response
    try:
        import getch
        print(q, end='')
        sys.stdout.flush()
        resp = getch.getche().lower()
        if resp != '\n':
            print()
        return resp == 'y'
    except:
        resp = input(q).lower()
        return resp and resp[0] == 'y'

def purge(files, args):
    for f in files:
        if args.force or prompt(f):
            print('Removing {}'.format(f))
            if os.path.isdir(f):
                from shutil import rmtree
                rmtree(f)
            else:
                os.remove(f)

def main():
    parser = argparse.ArgumentParser(description='Purges files from backup/snapshot directories', epilog="""
    If a directory is given, the files are purged recursively if the inodes under the directory exactly match the backup version(s), unless the --all flag is used.
    """)
    parser.add_argument('files', nargs='+', help='Files to purge')
    req = parser.add_argument_group('required arguments')
    req.add_argument('-I', metavar='DIRNAME', action='append', required=True, help='Backup directory name')
    req.add_argument('-d', '--depth', type=int, required=True, help='Depth of the backup directory structure')
    parser.add_argument('-f', '--force', action='store_true', help='Do not interactively prompt for each removal')
    parser.add_argument('-a', '--all', action='store_true', help='Purge backed up versions of FILES even if their inodes do not match')

    args = parser.parse_args()

    for f in args.files:
        purge(find(f, args), args)

if __name__ == '__main__':
    main()

