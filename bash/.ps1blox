# ------------------------------------------------------------------------------
# ps1blox - sets PS1 based on user-defined function blocks
#
# A "block" is a string of text printed by a function, which can be displayed 
# in any of the following regions of the prompt:
#
# - PS1BLOX_LEFT     : the left-justified region of the prompt
# - PS1BLOX_RIGHT    : the right-justified region of the prompt
# - PS1BLOX_NEXTLINE : the left-justified second line of the prompt
#
# Each region listed above is an array of blocks. Set these arrays with
# your own block functions in the order you want them displayed.
#
# For a single-line, left-justified prompt, only populate PS1BLOX_LEFT.
# For a two-line prompt, set PS1BLOX_LEFT, PS1BLOX_RIGHT, and PS1BLOX_NEXTLINE.
# 
#    PS1BLOX_LEFT=(
#      block1
#      block2
#    )
#
# To activate the blocks, set PROMPT_COMMAND to ps1blox_setprompt.
#
#    PROMPT_COMMAND=ps1blox_setprompt
#
# Writing a block function:
# 
# Each block should output a string of text without a trailing newline,
# e.g. using `echo -e` or `printf`. This text should be written to stdout.
#
# A block can be assigned *one* color using the ps1blox_color16 function.
# Simply call this function anywhere inside your block, giving a color ID from
# 0 to 15 as the sole argument, and it will apply to all the block text.
#
#    function block1 () {
#      echo -e "some_text"
#      ps1blox_color16 2 # blue
#    }
#
# Do not write anything else to stderr. Take care to redirect stderr to
# /dev/null for any command you may call from within the block function.
# 
# The following variables are available to be used in blocks:
#
# - PS1BLOX_RC  : the return code of the last command run by the shell
# - PS1BLOX_REM : the number of remaining columns in the line, useful for
#                 truncating a block if it won't fit in a line
#
# If this script was successfully sourced, it will export the variable
# PS1BLOX_ENABLED, which can be used as a hook for the sourcing script
# to decide whether to use ps1blox for setting the prompt, or some fallback
# method.
#
# If you want to update the window title (or tab title, if supported), on each
# redraw of the prompt, set these variables to a function which prints the 
# desired text to stdout:
#
# - PS1BLOX_WINTITLE : sets window title
# - PS1BLOX_TABTITLE : sets tab title
# ------------------------------------------------------------------------------

# Caches ANSI color codes from tput to global array
ps1blox_color16_init () {
    [[ -n ${PS1BLOX_COLORS+1} ]] && return
    PS1BLOX_COLORS=()
    PS1BLOX_RESET="$(tput sgr0)"
    local i
    for i in {0..15}; do
        PS1BLOX_COLORS+=("$(tput setaf "$i")")
    done
}

# Prints ANSI color code to stderr
ps1blox_color16 () {
    ps1blox_color16_init
    printf "%s" "${PS1BLOX_COLORS[$1]}" 1>&2
}

# Sets terminal window title
ps1blox_setwintitle () {
    echo -ne "\033]0;${1}\007"
}

# Sets terminal tab title
ps1blox_settabtitle () {
    echo -ne "\033]30;${1}\007"
}

# Sets PS1
# Caller should set PROMPT_COMMAND=ps1blox_setprompt
ps1blox_setprompt () {
    # These are variables that can be used from user blocks
    # Last command return value
    PS1BLOX_RC=${PS1BLOX_RC:-$?} # keep this line first!
    # Characters remaining on line
    PS1BLOX_REM=${COLUMNS?set checkwinsize}
    # end
    
    local _us=$'\x22' # ASCII unit separator
    local _block
    local _color
    local _text

    local _lhs
    _lhs=""
    for _block in "${PS1BLOX_LEFT[@]}"; do
        local _packed
        _packed=$(
            { text=$($_block); } 2>&1
            printf "%s%s" "${_us}" "${text}"
)
        _color="${_packed%%${_us}*}"
        _text="${_packed#*${_us}}"
        _lhs+="${_color:+\[${_color}\]}${_text}${_color:+\[$PS1BLOX_RESET\]}"
        (( PS1BLOX_REM -= ${#_text} ))
    done

    # Left-only: stop here, no new line
    PS1="${_lhs}"
    if [[ -z "${PS1BLOX_RIGHT+1}" ]]; then
        return
    fi

    # Left and right side: full line prompt
    PS1="\r${PS1}"

    local _rhs
    _rhs=""
    for _block in "${PS1BLOX_RIGHT[@]}"; do
        local _packed
        _packed=$(
            { text=$($_block); } 2>&1
            printf "%s%s" "${_us}" "${text}"
    )
        _color="${_packed%%${_us}*}"
        _text="${_packed#*${_us}}"
        _rhs+="${_color:+\[${_color}\]}${_text}${_color:+\[$PS1BLOX_RESET\]}"
        (( PS1BLOX_REM -= ${#_text} ))
    done

    local _ctr
    if [[ $PS1BLOX_REM -gt 0 ]]; then
        _ctr="$(printf "%${PS1BLOX_REM}s" "")"
    else
        _ctr=' '
    fi

    PS1+="${_ctr}${_rhs}\n"
    if [[ -z ${PS1BLOX_NEXTLINE+1} ]]; then
        return
    fi

    # Next line prompt
    PS1BLOX_REM=$COLUMNS
    local _next
    _next=""
    for _block in "${PS1BLOX_NEXTLINE[@]}"; do
        local _packed
        _packed=$(
            { text=$($_block); } 2>&1
            printf "%s%s" "${_us}" "${text}"
    )
        _color="${_packed%%${_us}*}"
        _text="${_packed#*${_us}}"
        _next+="${_color:+\[${_color}\]}${_text}${_color:+\[$PS1BLOX_RESET\]}"
        (( PS1BLOX_REM -= ${#_text} ))
    done
    
    [[ -n "${PS1BLOX_WINTITLE}" ]] && ps1blox_setwintitle "$($PS1BLOX_WINTITLE)"
    [[ -n "${PS1BLOX_TABTITLE}" ]] && ps1blox_settabtitle "$($PS1BLOX_TABTITLE)"

    PS1+="${_next}"
    
    # Clean up
    unset PS1BLOX_RC # important!
    unset PS1BLOX_REM
}

# Set up colors on source of this file
ps1blox_color16_init

export PS1BLOX_ENABLED=1

# vim:ft=sh
